#!/usr/bin/env fontforge
"""
FontForge Script to Fix Malformed CydFont.ttf

This script fixes the structural issues in fonts generated by IcoMoon:
- Corrects incorrect glyph bounding boxes
- Removes overlapping path segments
- Fixes whitespace glyphs
- Adds proper .notdef glyph
- Corrects font metrics
- Applies autohinting

Usage:
    fontforge -script scripts/fix-font.py assets/fonts/CydFont.ttf assets/fonts/CydFont_fixed.ttf
    
Or:
    fontforge -script scripts/fix-font.py assets/fonts/CydFont.ttf
    (will overwrite the original file)
"""

import sys
import fontforge
import os

def fix_font(input_path, output_path=None):
    """
    Fix malformed font file
    
    Args:
        input_path: Path to the input font file
        output_path: Path for output file (optional, defaults to overwriting input)
    """
    print(f"Opening font: {input_path}")
    
    try:
        font = fontforge.open(input_path)
    except Exception as e:
        print(f"ERROR: Could not open font file: {e}")
        sys.exit(1)
    
    print(f"Font family: {font.familyname}")
    print(f"Font version: {font.version}")
    print(f"Number of glyphs: {len(font)}")
    print()
    
    # Step 1: Fix all glyph bounding boxes and paths
    print("Step 1: Fixing glyph bounding boxes and paths...")
    fixed_glyphs = 0
    
    for glyph in font.glyphs():
        if glyph.isWorthOutputting():
            try:
                # Select the glyph
                font.selection.select(glyph.glyphname)
                
                # Remove overlap (fixes overlapping path segments)
                glyph.removeOverlap()
                
                # Correct path direction
                glyph.correctDirection()
                
                # Round to integers (eliminates sub-pixel coordinates)
                glyph.round()
                
                # Add extrema points (helps with bbox calculation)
                glyph.addExtrema("all")
                
                # Simplify paths
                glyph.simplify(1.5)
                
                fixed_glyphs += 1
                
            except Exception as e:
                print(f"  Warning: Could not fix glyph '{glyph.glyphname}': {e}")
    
    print(f"  Fixed {fixed_glyphs} glyphs")
    print()
    
    # Step 2: Clear whitespace glyphs
    print("Step 2: Clearing whitespace glyphs...")
    whitespace_glyphs = [
        'space',      # U+0020
        'uni0000',    # U+0000 null
        'uni0001',    # U+0001 control char
        'uni00A0',    # U+00A0 non-breaking space (if exists)
    ]
    
    for glyph_name in whitespace_glyphs:
        if glyph_name in font:
            try:
                glyph = font[glyph_name]
                # Clear the glyph (remove all contours)
                glyph.clear()
                # Set width (keep original width for proper spacing)
                if glyph_name == 'space' or glyph_name == 'uni00A0':
                    glyph.width = 512  # Standard space width
                else:
                    glyph.width = 0
                print(f"  Cleared glyph: {glyph_name}")
            except Exception as e:
                print(f"  Warning: Could not clear glyph '{glyph_name}': {e}")
    print()
    
    # Step 3: Ensure .notdef has a visible glyph
    print("Step 3: Adding .notdef glyph...")
    if '.notdef' in font:
        try:
            notdef = font['.notdef']
            # Check if .notdef is empty
            if not notdef.isWorthOutputting():
                # Clear and redraw
                notdef.clear()
                
                # Create a simple rectangle for .notdef
                pen = notdef.glyphPen()
                
                # Draw outer rectangle
                pen.moveTo((100, 0))
                pen.lineTo((100, 700))
                pen.lineTo((400, 700))
                pen.lineTo((400, 0))
                pen.closePath()
                
                # Draw inner rectangle (to create hollow box)
                pen.moveTo((150, 50))
                pen.lineTo((350, 50))
                pen.lineTo((350, 650))
                pen.lineTo((150, 650))
                pen.closePath()
                
                pen = None
                
                notdef.width = 500
                print("  Created .notdef glyph with visible rectangle")
            else:
                print("  .notdef glyph already has content")
        except Exception as e:
            print(f"  Warning: Could not fix .notdef: {e}")
    else:
        print("  Warning: .notdef glyph not found in font")
    print()
    
    # Step 4: Fix font metrics
    print("Step 4: Fixing font metrics...")
    try:
        # Set OS/2 table values
        font.os2_typolinegap = 0
        font.hhea_linegap = 0
        
        # Ensure consistent metrics
        font.os2_typoascent = font.hhea_ascent
        font.os2_typodescent = font.hhea_descent
        
        print("  Fixed line gap metrics")
    except Exception as e:
        print(f"  Warning: Could not fix metrics: {e}")
    print()
    
    # Step 5: Auto-hint all glyphs
    print("Step 5: Auto-hinting glyphs...")
    try:
        font.selection.all()
        font.autoHint()
        print("  Applied autohinting to all glyphs")
    except Exception as e:
        print(f"  Warning: Auto-hinting failed: {e}")
    print()
    
    # Step 6: Validate and generate
    print("Step 6: Validating font...")
    validation_state = font.validate(True)
    
    if validation_state == 0:
        print("  ✓ Font validation passed")
    else:
        print(f"  ⚠ Font has validation warnings (code: {validation_state})")
        print("  This is common and may not be critical")
    print()
    
    # Step 7: Generate fixed font
    output_file = output_path if output_path else input_path
    print(f"Step 7: Generating fixed font: {output_file}")
    
    try:
        # Generate TTF with the following options:
        # - opentype: Generate OpenType tables
        # - dummy-dsig: Add dummy DSIG table
        # - round: Round coordinates
        font.generate(
            output_file,
            flags=('opentype', 'round', 'dummy-dsig')
        )
        print("  ✓ Font generated successfully")
    except Exception as e:
        print(f"  ERROR: Could not generate font: {e}")
        sys.exit(1)
    
    # Close font
    font.close()
    
    print()
    print("=" * 60)
    print("✓ Font fixing complete!")
    print("=" * 60)
    print()
    print("Next steps:")
    print(f"1. Validate: ots-sanitize '{output_file}'")
    print(f"2. Check: fontbakery check-universal '{output_file}'")
    print(f"3. Test in iOS Simulator")
    print()


def main():
    """Main entry point"""
    if len(sys.argv) < 2:
        print("Usage: fontforge -script fix-font.py <input.ttf> [output.ttf]")
        print()
        print("If output.ttf is not specified, the input file will be overwritten.")
        sys.exit(1)
    
    input_path = sys.argv[1]
    output_path = sys.argv[2] if len(sys.argv) > 2 else None
    
    if not os.path.exists(input_path):
        print(f"ERROR: Input file not found: {input_path}")
        sys.exit(1)
    
    # If no output path specified, warn about overwrite
    if not output_path:
        print("WARNING: No output file specified. Will overwrite input file.")
        print(f"Input file: {input_path}")
        print()
        response = input("Continue? [y/N]: ")
        if response.lower() != 'y':
            print("Aborted.")
            sys.exit(0)
    
    fix_font(input_path, output_path)


if __name__ == '__main__':
    main()


